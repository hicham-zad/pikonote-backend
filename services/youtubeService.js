import { YoutubeTranscript } from '@danielxceron/youtube-transcript';
import { Innertube, UniversalCache } from 'youtubei.js';
import ytdl from '@distube/ytdl-core';
import axios from 'axios';
import { HttpsProxyAgent } from 'https-proxy-agent';
import { google } from 'googleapis';
import {
  TranscriptError,
  TRANSCRIPT_ERRORS,
  detectErrorType,
  ERROR_MESSAGES
} from './youtubeErrors.js';
import { getTranscriptFromRapidAPI } from './youtube-rapidapi.service.js';

let youtubeClient = null;

const getYoutubeClient = async () => {
  if (!youtubeClient) {
    const config = {
      cache: new UniversalCache(false),
      generate_session_locally: true,
      // Suppress non-critical parser warnings (new YouTube features not yet supported)
      enable_safety_mode: false,
      retrieve_player: false, // Skip player which causes most parser errors
    };

    if (process.env.YOUTUBE_COOKIES) {
      config.cookie = process.env.YOUTUBE_COOKIES;
    }

    if (process.env.PROXY_URL) {
      config.proxy = {
        url: process.env.PROXY_URL,
      }
    }

    youtubeClient = await Innertube.create(config);
  }
  return youtubeClient;
};

// Helper to parse cookies string "key=value; key2=value2" into array for ytdl
const parseCookies = (cookieStr) => {
  if (!cookieStr) return undefined;
  try {
    return cookieStr.split(';').map(c => {
      const parts = c.split('=');
      const key = parts[0]?.trim();
      const value = parts.slice(1).join('=').trim();
      if (key && value) return { name: key, value };
      return null;
    }).filter(c => c);
  } catch (e) {
    console.warn('Failed to parse cookies:', e);
    return undefined;
  }
};

/**
 * Check video availability and caption status before extraction
 * @param {string} videoId - YouTube video ID
 * @returns {Object} Video availability info
 */
export const checkVideoAvailability = async (videoId) => {
  const result = {
    videoId,
    exists: false,
    isPrivate: false,
    isAgeRestricted: false,
    isLiveStream: false,
    isRegionBlocked: false,
    hasCaptions: false,
    hasAutoCaptions: false,
    hasManualCaptions: false,
    captionLanguages: [],
    title: null,
    duration: null,
    durationSeconds: null,
    error: null,
  };

  try {
    // Try using ytdl-core first (fastest)
    const info = await ytdl.getBasicInfo(`https://www.youtube.com/watch?v=${videoId}`);
    const details = info.videoDetails;
    const playerResponse = info.player_response;

    result.exists = true;
    result.title = details.title;
    result.duration = details.lengthSeconds;
    result.durationSeconds = parseInt(details.lengthSeconds, 10);

    // Check for live stream
    if (details.isLive || details.isLiveContent) {
      result.isLiveStream = true;
    }

    // Check for age restriction
    if (playerResponse?.playabilityStatus?.reason?.includes('age') ||
      details.age_restricted) {
      result.isAgeRestricted = true;
    }

    // Check for captions
    const captions = playerResponse?.captions?.playerCaptionsTracklistRenderer?.captionTracks;
    if (captions && captions.length > 0) {
      result.hasCaptions = true;
      result.captionLanguages = captions.map(c => ({
        code: c.languageCode,
        name: c.name?.simpleText || c.languageCode,
        isAutoGenerated: c.kind === 'asr',
      }));
      result.hasAutoCaptions = captions.some(c => c.kind === 'asr');
      result.hasManualCaptions = captions.some(c => c.kind !== 'asr');
    }

    // Check duration limit (3 hours = 10800 seconds)
    if (result.durationSeconds > 10800) {
      result.error = TRANSCRIPT_ERRORS.VIDEO_TOO_LONG;
    }

  } catch (error) {
    const msg = error.message?.toLowerCase() || '';

    if (msg.includes('private') || msg.includes('sign in')) {
      result.isPrivate = true;
      result.error = TRANSCRIPT_ERRORS.VIDEO_PRIVATE;
    } else if (msg.includes('age') || msg.includes('confirm')) {
      result.isAgeRestricted = true;
      result.error = TRANSCRIPT_ERRORS.VIDEO_AGE_RESTRICTED;
    } else if (msg.includes('unavailable') || msg.includes('not found') || msg.includes('does not exist')) {
      result.error = TRANSCRIPT_ERRORS.VIDEO_NOT_FOUND;
    } else if (msg.includes('blocked') || msg.includes('country')) {
      result.isRegionBlocked = true;
      result.error = TRANSCRIPT_ERRORS.REGION_BLOCKED;
    } else {
      // Try YouTube API as backup
      try {
        const apiKey = process.env.YOUTUBE_API_KEY;
        if (apiKey) {
          const youtube = google.youtube({ version: 'v3', auth: apiKey });
          const response = await youtube.videos.list({
            part: ['snippet', 'contentDetails', 'status'],
            id: [videoId],
          });

          if (response.data.items && response.data.items.length > 0) {
            const video = response.data.items[0];
            result.exists = true;
            result.title = video.snippet?.title;

            // Parse duration (ISO 8601)
            const duration = video.contentDetails?.duration;
            if (duration) {
              const match = duration.match(/PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/);
              if (match) {
                const hours = parseInt(match[1] || 0);
                const minutes = parseInt(match[2] || 0);
                const seconds = parseInt(match[3] || 0);
                result.durationSeconds = hours * 3600 + minutes * 60 + seconds;
              }
            }
          } else {
            result.error = TRANSCRIPT_ERRORS.VIDEO_NOT_FOUND;
          }
        }
      } catch (apiError) {
        console.warn('YouTube API fallback failed:', apiError.message);
        result.error = TRANSCRIPT_ERRORS.VIDEO_NOT_FOUND;
      }
    }
  }

  return result;
};

// Strategy 4: YouTube Data API v3
const extractWithYouTubeAPI = async (videoId) => {
  const apiKey = process.env.YOUTUBE_API_KEY;
  if (!apiKey) {
    throw new Error('YOUTUBE_API_KEY not configured');
  }

  console.log('ðŸ”‘ Strategy 4: Attempting YouTube Data API v3...');

  const youtube = google.youtube({ version: 'v3', auth: apiKey });

  // Step 1: Get video details for title
  const videoResponse = await youtube.videos.list({
    part: ['snippet'],
    id: [videoId],
  });

  const videoTitle = videoResponse.data.items?.[0]?.snippet?.title || `YouTube Video ${videoId}`;

  // Step 2: Get caption tracks
  const captionsResponse = await youtube.captions.list({
    part: ['snippet'],
    videoId: videoId,
  });

  const captions = captionsResponse.data.items;
  if (!captions || captions.length === 0) {
    throw new Error('No captions available via YouTube API');
  }

  // Prefer English, otherwise take first available
  const englishCaption = captions.find(c => c.snippet?.language === 'en');
  const caption = englishCaption || captions[0];
  const captionId = caption.id;

  console.log(`ðŸ“ Found caption track: ${caption.snippet?.name || caption.snippet?.language}`);

  // Step 3: Download caption content
  // Note: This requires OAuth for third-party captions, but works for auto-captions
  // For auto-captions, we'll use the timedtext endpoint as fallback
  try {
    const captionResponse = await youtube.captions.download({
      id: captionId,
      tfmt: 'srt', // Get as SRT format
    });

    if (captionResponse.data) {
      // Parse SRT to plain text
      const srtText = captionResponse.data;
      const text = srtText
        .split('\n')
        .filter(line => !line.match(/^\d+$/) && !line.match(/^\d{2}:\d{2}:\d{2}/))
        .join(' ')
        .replace(/\s+/g, ' ')
        .trim();

      console.log('âœ… Strategy 4 success!');
      return {
        text,
        title: videoTitle,
        duration: null,
        videoId,
      };
    }
  } catch (downloadError) {
    console.warn('Direct caption download failed (may need OAuth):', downloadError.message);

    // Fallback: Use timedtext API for auto-generated captions
    const lang = caption.snippet?.language || 'en';
    const timedTextUrl = `https://www.youtube.com/api/timedtext?v=${videoId}&lang=${lang}&fmt=srv3`;

    try {
      const response = await axios.get(timedTextUrl, {
        headers: {
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
        }
      });

      if (response.data) {
        // Parse XML transcript
        const matches = [...response.data.matchAll(/<text[^>]*>(.*?)<\/text>/g)];
        const text = matches.map(m => {
          return m[1]
            .replace(/&amp;/g, '&')
            .replace(/&lt;/g, '<')
            .replace(/&gt;/g, '>')
            .replace(/&quot;/g, '"')
            .replace(/&#39;/g, "'");
        }).join(' ');

        if (text.length > 0) {
          console.log('âœ… Strategy 4 success (via timedtext fallback)!');
          return {
            text,
            title: videoTitle,
            duration: null,
            videoId,
          };
        }
      }
    } catch (timedTextError) {
      console.warn('Timedtext fallback failed:', timedTextError.message);
    }
  }

  throw new Error('Failed to download captions via YouTube API');
};

export const extractYouTubeTranscript = async (url, options = {}) => {
  const { skipPreflightCheck = false } = options;

  // Extract and validate video ID
  let videoId;
  try {
    videoId = extractVideoId(url);
  } catch (e) {
    throw new TranscriptError(TRANSCRIPT_ERRORS.INVALID_URL, null, { url });
  }

  console.log(`ðŸŽ¥ Attempting to extract transcript for video ID: ${videoId}`);
  console.log(`ðŸ“º Full URL: ${url}`);

  // Store video metadata (title, duration) from pre-flight check
  let videoTitle = null;
  let videoDuration = null;

  // Pre-flight availability check (non-blocking - cloud IPs often get blocked)
  if (!skipPreflightCheck) {
    console.log('ðŸ” Running pre-flight availability check...');
    try {
      const availability = await checkVideoAvailability(videoId);

      if (availability.error) {
        // Log but don't fail - cloud server IPs often get false positives
        console.warn(`âš ï¸ Pre-flight check returned: ${availability.error}`);
        console.log('ðŸ”„ Continuing with extraction strategies anyway (cloud IP may be blocked)...');
      } else {
        if (!availability.hasCaptions) {
          console.warn('âš ï¸ No captions detected for this video');
          // Don't fail yet - strategies might still work with auto-captions
        }

        // Store metadata for later use
        videoTitle = availability.title;
        videoDuration = availability.durationSeconds;

        console.log(`âœ… Pre-flight check passed: ${videoTitle || videoId}`);
      }
    } catch (preflightError) {
      // Pre-flight failed completely - continue anyway
      console.warn('âš ï¸ Pre-flight check failed:', preflightError.message);
      console.log('ðŸ”„ Continuing with extraction strategies...');
    }
  }

  // Setup Agents for YTDL
  const proxyUrl = process.env.PROXY_URL;
  const cookies = parseCookies(process.env.YOUTUBE_COOKIES);

  let ytdlAgent;
  try {
    const agentOptions = {};
    if (proxyUrl) {
      console.log('ðŸ”— Using Proxy for YouTube extraction');
      agentOptions.http = new HttpsProxyAgent(proxyUrl);
      agentOptions.https = new HttpsProxyAgent(proxyUrl);
    }

    ytdlAgent = ytdl.createAgent(cookies, agentOptions);
  } catch (e) {
    console.warn('Failed to create YTDL agent:', e);
  }

  // Track errors from each strategy for better diagnostics
  const strategyErrors = [];

  // Strategy 1: Fast Scraper (youtube-transcript library - most reliable free method)
  try {
    console.log('âš¡ï¸ Strategy 1: youtube-transcript library...');
    const transcriptData = await YoutubeTranscript.fetchTranscript(videoId);

    if (transcriptData && transcriptData.length > 0) {
      console.log(`âœ… Strategy 1 success! Segments: ${transcriptData.length}`);
      const text = transcriptData.map(segment => segment.text).join(' ');
      return {
        text,
        title: videoTitle || `YouTube Video ${videoId}`,
        duration: videoDuration,
        videoId,
      };
    }
  } catch (error) {
    console.warn('âŒ Strategy 1 failed:', error.message);
    strategyErrors.push({ strategy: 1, error: error.message });
  }

  // Strategy 2: Direct timedtext API (reliable, no auth required)
  try {
    console.log('ðŸ”— Strategy 2: Direct timedtext API...');

    // Get available caption tracks
    const trackListUrl = `https://www.youtube.com/watch?v=${videoId}`;
    const pageResponse = await axios.get(trackListUrl);
    const pageHtml = pageResponse.data;

    // If we don't have title yet, try to extract from page
    if (!videoTitle) {
      const titleMatch = pageHtml.match(/"title":"([^"]+)"/);
      if (titleMatch) {
        videoTitle = titleMatch[1].replace(/\\u0026/g, '&').replace(/\\'/g, "'");
        console.log(`ðŸ“ Extracted title from page: ${videoTitle}`);
      }
    }

    // Extract caption tracks from page
    const captionsMatch = pageHtml.match(/"captionTracks":\s*(\[.*?\])/);
    if (captionsMatch) {
      const tracks = JSON.parse(captionsMatch[1]);

      // Prefer English, non-auto-generated
      const englishTrack = tracks.find(t => t.languageCode === 'en' && !t.kind) ||
        tracks.find(t => t.languageCode === 'en') ||
        tracks[0];

      if (englishTrack && englishTrack.baseUrl) {
        const transcriptResponse = await axios.get(englishTrack.baseUrl);
        const xml = transcriptResponse.data;

        // Parse XML
        const matches = [...xml.matchAll(/<text[^>]*>(.*?)<\/text>/g)];
        const text = matches.map(m => {
          return m[1]
            .replace(/&amp;/g, '&')
            .replace(/&lt;/g, '<')
            .replace(/&gt;/g, '>')
            .replace(/&quot;/g, '"')
            .replace(/&#39;/g, "'");
        }).join(' ');

        if (text.length > 100) {
          console.log(`âœ… Strategy 2 success! (${text.length} chars)`);
          return {
            text,
            title: videoTitle || `YouTube Video ${videoId}`,
            duration: videoDuration,
            videoId,
          };
        }
      }
    }

    throw new Error('No caption tracks found');
  } catch (error) {
    console.warn('âŒ Strategy 2 failed:', error.message);
    strategyErrors.push({ strategy: 2, error: error.message });
  }

  // Strategy 3: YouTube Data API v3 (Official)
  try {
    return await extractWithYouTubeAPI(videoId);
  } catch (error) {
    console.warn('âŒ Strategy 3 failed:', error.message);
    strategyErrors.push({ strategy: 3, error: error.message });
  }

  // Strategy 3.5: Piped API (Public Instances) - Bypasses Server IP 429
  // Piped instances proxy the request, so they don't use our server's IP
  const pipedInstances = [
    'https://pipedapi.kavin.rocks',
    'https://api.piped.privacy.com.de',
    'https://pipedapi.drgns.space',
    'https://pipedapi.r4fo.com',
    'https://api.piped.projectsegfau.lt'
  ];

  console.log('ðŸ›¡ï¸ Strategy 3.5: Attempting Piped API (public proxies)...');
  for (const instance of pipedInstances) {
    try {
      const response = await axios.get(`${instance}/streams/${videoId}`, { timeout: 3000 });
      const subtitles = response.data?.subtitles;

      if (subtitles && subtitles.length > 0) {
        // Prefer English
        const track = subtitles.find(s => s.code === 'en') || subtitles[0];

        if (track) {
          console.log(`ðŸ“¡ Piped Instance hit: ${instance}`);
          // Fetch the actual subtitle content
          const textRes = await axios.get(track.url);
          const rawText = textRes.data;

          if (rawText) {
            // Simple VTT cleanup
            let text = rawText
              .replace(/WEBVTT\n/g, '')
              .replace(/(\d{2}:\d{2}:\d{2}\.\d{3} --> \d{2}:\d{2}:\d{2}\.\d{3})/g, '') // Remove timestamps
              .replace(/<[^>]*>/g, '') // Remove HTML tags
              .replace(/\n+/g, ' ') // Collapse newlines
              .trim();

            if (text.length > 50) {
              console.log(`âœ… Strategy 3.5 success! (${text.length} chars)`);
              return {
                text,
                title: videoTitle || `YouTube Video ${videoId}`,
                duration: videoDuration,
                videoId,
                source: 'piped'
              };
            }
          }
        }
      }
    } catch (e) {
      // Continue to next instance
    }
  }
  strategyErrors.push({ strategy: 3.5, error: 'All Piped instances failed' });

  // Strategy 4: RapidAPI YouTube Transcripts (Paid Fallback)
  try {
    console.log('ðŸ’° Strategy 4: Attempting RapidAPI (paid fallback)...');
    const rapidAPIResult = await getTranscriptFromRapidAPI(videoId);

    if (rapidAPIResult && rapidAPIResult.text) {
      console.log(`âœ… Strategy 4 success! (${rapidAPIResult.text.length} chars)`);

      // Log quota usage
      if (rapidAPIResult.quota) {
        console.log(`ðŸ“Š RapidAPI Quota: ${rapidAPIResult.quota.remaining}/${rapidAPIResult.quota.limit} remaining`);
      }

      return {
        text: rapidAPIResult.text,
        title: videoTitle || `YouTube Video ${videoId}`,
        duration: videoDuration,
        videoId,
        source: 'rapidapi',
      };
    }
  } catch (error) {
    console.warn('âŒ Strategy 4 failed:', error.message);
    strategyErrors.push({ strategy: 5, error: error.message });

    // Check if rate limited
    if (error.message.includes('RATE_LIMITED')) {
      console.error('ðŸš¨ RapidAPI quota exceeded!');
    }
  }

  // All strategies failed - determine the most likely cause
  console.error('âŒ All extraction strategies failed:', strategyErrors);

  // Check if any error indicates no captions
  const noCaptionsError = strategyErrors.find(e =>
    e.error?.toLowerCase().includes('caption') ||
    e.error?.toLowerCase().includes('subtitle') ||
    e.error?.toLowerCase().includes('transcript')
  );

  if (noCaptionsError) {
    throw new TranscriptError(
      TRANSCRIPT_ERRORS.NO_CAPTIONS_AVAILABLE,
      null,
      { videoId, strategies: strategyErrors }
    );
  }

  // Default to extraction failed
  throw new TranscriptError(
    TRANSCRIPT_ERRORS.EXTRACTION_FAILED,
    'All extraction strategies failed. The video may have captions disabled or be temporarily unavailable.',
    { videoId, strategies: strategyErrors }
  );
};

// Helper to extract video ID from various YouTube URL formats
export const extractVideoId = (url) => {
  const patterns = [
    /(?:youtube\.com\/watch\?v=|youtu\.be\/)([^&\n?#]+)/,
    /youtube\.com\/embed\/([^&\n?#]+)/,
    /youtube\.com\/shorts\/([^&\n?#]+)/,
  ];

  for (const pattern of patterns) {
    const match = url.match(pattern);
    if (match) return match[1];
  }

  throw new TranscriptError(TRANSCRIPT_ERRORS.INVALID_URL, null, { url });
};